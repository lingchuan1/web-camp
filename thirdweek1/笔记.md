1. 多态                           
>java引用变量有两个类型，一个是编译时类型，一个是运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定，如果编译时类型和运行时类型不一致，就可能出现所谓的多态。                

>- 引用多态：父类的引用可以指向本类对象，父类的引用也可以指向子类对象
>- 方法多态：创建本类对象时，调用的方法为本类方法，创建子类对象时，调用的方法为子类重写的方法或者继承的方法，不能调用子类独有的方法             
>- 与方法不同，对象的实例变量则不具备多态性。通过引用变量来访问其包含的实例变量时，系统总是试图访问它编译时类型所定义的成员变量，所以只能访问父类的实例变量。
2.
>instanceof运算符：instanceof运算符的前一个操作数是一个引用类型变量，后一个操作数通常是一个类，也可以是一个接口          
作用：在进行强制转换之前，首先判断前一个对象是否是后一个类的实例，是否可以成功转换，使代码更加健壮
eg:Object hello = "Hello";      
   hello instanceof Object   判断Hello是否使Object类的实例
             
3.方法重载
>同一个类中方法名相同，形参列表不同（形参长度，形参数据类型，形参顺序）       
>系统会根据形参列表不同，区分出调用的是哪个方法            
方法的返回值类型不能用于区分重载的方法

4. fianl 关键字
- 修饰类：该类不允许被继承
- 修饰方法：该方法不允许被重写
- 修饰属性：该属性不会进行隐式初始化
- 修饰变量：该变量只能赋一次值
- 修饰引用变量：所引用的地址不会改变，但这个对象可以改变         
- 
5. static关键字
- 方便在没有创建对象的时候来进行调用（方法/变量），只要类被加载了，就可以通过类名去进行访问
- static方法
>不依赖于对象，所以没有this      
>在静态方法中不能访问类的非静态成员和非静态成员方法，因为非静态成员方法/变量都必须依赖具体的对象才能被调用
- static变量
>被所有的对象所共享，当且仅当在类初次加载时会被初始化
- static代码块
>只会在类加载的时候执行一次 
6. super关键字
- super 用于限定该对象调用它从父类继承得到的实例变量或方法
- 正如this不能出现在static中修饰的方法一样，super也不能出现在static修饰的方法中。static修饰的方法时属于类的，super用于限定对象
6. 自动类型转换               


- 小换大可以         
```
int a = 6;
float f = a;
//下面将输出6.0
System.out.println(f);
```
- 把基本类型和字符串类型连接运算时，基本类型的值将自动类型转换为字符串类型（如果希望把一个基本类型的值转换为字符串时，可以把基本类型的值和一个空字符串进行连接）
```
//下面语句输出7Hello!
System.out.println("3+4+Hello!");
//下面语句输出Hello!34
System.out.println("Hello+3+4");
```               
7. 强制类型转换
- 缩小转换，要注意是否溢出
```
//强制把一个int类型的值转换为一个byte类型的值
int iValue = 233;
byte bValte = (byte)iValue;
System.out.println(bValue);//输出-23                           
```
- 直接把5.6赋值给float型变量将出现错误，因为float型默认是double类型，应写出
```
float a = (float)5.6;
或float a = 5.6f;
```
- 在通常情况下，字符串不能直接转换为基本类型，但通过基本类型的包装类可以实现。包装类提供了一个parseXxx(String str)静态方法，用于将字符串转换成基本类型。
```
String a = "45";
//使用Integer的方法将一个字符串转换成int型
int Value = Integer.parseInt(a);
```

8. 成员变量 
- 在类里定义的变量
- 类变量：以static修饰；实例变量：不以static修饰
- 类变量的作用域与这个类的生存范围相同，而实例变量则从该类的实例被创建起开始存在，直到系统完全销毁这个实例       
- 类变量可以通过类来访问，也可以通过实例来访问。同一个类的所有实例访问类变量时，实际上访问的是该类本身的同一个变量，也就是说，访问了同一片内存区。
- 成员变量无需显示初始化，系统会在这个类的准备阶段或创建该类的实例时进行默认初始化

9. 局部变量
- 在方法里定义的变量
- 形参不用显示初始化，方法局部变量和代码块局部变量都需要显示初始化
- 如果方法里的局部变量和成员变量同名，局部变量会覆盖成员变量，如果需要在这个方法里引用被覆盖的成员变量，则可以用this(对于实例变量)或类名（对于类变量）作为调用者来限定访问成员变量
10. 构造器
>当调用构造器时，系统会先为对象分配内存空间，并执行默认初始化。当系统开始执行构造器的执行体之前，系统已经创建了一个对象，只是这个对象还不能被外部程序访问，只能在该构造器中通过this来引用。当构造器的执行体执行结束后，这个对象作为构造器的返回值被返回，通常还会赋给另一个引用类型的变量，从而让外部程序可以访问该对象          
- 构造器的名字与类名相同
- 构造器允许重载
- 通常把构造器设置成public访问权限，从而允许系统中任何位置的类来创建该类的对象
- 如果构造器B完全包含了构造器A，为了在构造器B中调用构造器A的初始化代码，又不会重新创建一个对象，可以使用this关键字来调用相应的构造器。
```
public Apple(String name,String color){
    this.name = name;
    this.color = color;
}
public Apple(String name,String color,double weight){
    this(name,color);//通过this调用另一个重载的构造器的初始化代码
    this.weight = weight;
}
```
11. 初始化块
- 初始化块没有名字，也就没有标识，因此无法通过类、对象来调用初始化块
- 初始化块只在创建java对象时隐式执行，而且在执行构造器之前执行
- 初始化块对同一个类的所有对象所进行的初始化处理完全相同，所以如果有一段初始化处理代码对所有对象完全相同，且无需接收任何参数，就可以把这段初始化处理代码提取到初始化块中
- 静态初始化块是类相关的，系统将在类初始化阶段执行静态初始化块，而不是在创建对象时才执行。因此静态初始化块总是比普通初始化块先执行。
- 静态初始化块用于对类变量执行初始化处理，不能对实例变量进行初始化处理